# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2019, GitExtensions
# This file is distributed under the same license as the GitExtensions package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GitExtensions 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-11 22:41+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../branches.rst:4
msgid "Branches"
msgstr ""

#: ../branches.rst:9
msgid "Branches are used to commit changes separate from other commits. It is very common to create a new branch when you start working on a feature to keep the work done on that feature separate from other work. When the feature is complete the branch can be merged or rebased as you choose such that the commits for the feature either remain as a parallel branch or appear as a continuous single line of development as if the branch had never existed in the first place. The image on the right illustrates a branch created on top of commit B."
msgstr ""

#: ../branches.rst:15
msgid "You can see the name of your current branch in a combo box in the toolbar. You can switch to another branch by choosing from the combo box list. In the commit log the current branch has an arrow head to the left of its name. If you are not currently on a branch because you have checked out a specific commit but not any particular branch then Git Extensions will show ``(no branch)`` in place of a branch name in the toolbar. This is called \"Detached HEAD mode\". In Git you can refer to your current branch or commit by the special reference ``HEAD`` in place of the branch name or commit reference."
msgstr ""

#: ../branches.rst:25
msgid "Create branch"
msgstr ""

#: ../branches.rst:27
msgid "In Git Extensions there are multiple ways to create a new branch. In the image below I create a new branch from the context menu in the commit log. This will create a new branch on the revision that is selected."
msgstr ""

#: ../branches.rst:32
msgid "I will create a new branch called ``feature/refactor``. In this branch I can do whatever I want without affecting others. The default in Git Extensions is to check out a new branch after it is created. If you want to create a new branch but remain on your current branch, uncheck the ``Checkout after create`` checkbox in the ``Create branch`` dialog."
msgstr ""

#: ../branches.rst:38
msgid "When the branch is created you will see the new branch ``feature/refactor`` in the commit log. If you chose to checkout this branch the next commit will be committed to the new branch."
msgstr ""

#: ../branches.rst:43
msgid "Creating branches in Git requires only 41 bytes of space in the repository. Creating a new branch is very easy and fast. The complete work flow of Git is optimized for branching and merging."
msgstr ""

#: ../branches.rst:47
msgid "Orphan branches"
msgstr ""

#: ../branches.rst:48
msgid "In special cases it is helpful to have orphan branches (see for example https://www.google.com/search?q=why+use+orphan+branches+in+git). Check the \"Create orphan\" checkbox to create an orphan branch (``--orphan`` option in git)."
msgstr ""

#: ../branches.rst:51
msgid "The newly created branch will have no parent commits."
msgstr ""

#: ../branches.rst:53
msgid "The option \"Clear working dir and index\" (``git rm -rf``) is active by default. So the working dir and index will be cleared. If you uncheck the last option then the working dir and index will not be touched."
msgstr ""

#: ../branches.rst:57
msgid "Checkout branch"
msgstr ""

#: ../branches.rst:59
msgid "You can switch from the current branch to another branch using the checkout command. Checking out a branch sets the current branch and updates all of the source files in the working directory. Uncommitted changes in the working directory can be overwritten so it is best practice to make sure your working directory is clean by either committing or stashing any current changes before checking out a branch. If you do not clean your working directory then, in the ``Checkout branch`` dialog, you can choose between four options for your local uncommitted changes:"
msgstr ""

#: ../branches.rst:66
msgid "``Don't change``"
msgstr ""

#: ../branches.rst:66
msgid "Local changes will be retained if there are not conflicting changes from the branch you are checking out."
msgstr ""

#: ../branches.rst:68
msgid "``Merge``"
msgstr ""

#: ../branches.rst:68
msgid "Performs a three-way merge between your current branch, your local changes and the branch you are checking out."
msgstr ""

#: ../branches.rst:70
msgid "``Stash``"
msgstr ""

#: ../branches.rst:70
msgid "Your local changes are stashed and the new branch is checked out. You can retrieve your changes on the new branch with stash-pop."
msgstr ""

#: ../branches.rst:72
msgid "``Reset``"
msgstr ""

#: ../branches.rst:72
msgid "Your local changes are discarded and the new branch is checked out. Use caution with this option as Git has no record of uncommitted changes so they cannot be retrieved."
msgstr ""

#: ../branches.rst:78
msgid "Merge branches"
msgstr ""

#: ../branches.rst:80
msgid "In the image below there are two branches, ``[feature/refactor]`` and ``[master]``. We can merge the commits from the master branch into the feature/refactor branch. If we do this, the feature/refactor branch will be up to date with the master branch, but not the other way around. As long as we are working on the feature/refactor branch we cannot touch the master branch itself. We can merge the sources of master into our branch, but cannot make any change to the master branch."
msgstr ""

#: ../branches.rst:87
msgid "To merge the feature/refactor branch into the master branch, we first need to switch to the master branch."
msgstr ""

#: ../branches.rst:91
msgid "Once we are on the master branch, select the feature/refactor branch and select merge. Alternatively choose ``Merge branches`` from the ``Commands`` menu and select the feature/refactor branch."
msgstr ""

#: ../branches.rst:95
msgid "In the merge dialog you can verify which branch you are working on, as well as set advanced merge options (see :ref:`Advanced Merge Options`). Select the branch to merge with then click the ``Merge`` button."
msgstr ""

#: ../branches.rst:99
msgid "After the merge the commit log will show the new commit containing the merge. Notice that the feature/refactor branch is not changed by this merge. If you want to continue working on the feature/refactor branch you can merge the feature/refactor branch with master. You can instead delete the feature/refactor branch if it is not used anymore."
msgstr ""

#: ../branches.rst:107
msgid "When you need to merge with an unnamed branch you can use a tag to give it a temporary name."
msgstr ""

#: ../branches.rst:111
msgid "During a merge conflicts can occur. See :ref:`merge_conflicts` for more information."
msgstr ""

#: ../branches.rst:116
msgid "Advanced Merge Options"
msgstr ""

#: ../branches.rst:118
msgid "The `Show advanced options` checkbox will show the following options when activated:"
msgstr ""

#: ../branches.rst:120
msgid "Use non-default merge strategy, with a drop-down field for selecting the alternate merge strategy. The strategies are:"
msgstr ""

#: ../branches.rst:122
msgid "**resolve**"
msgstr ""

#: ../branches.rst:124
msgid "This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast."
msgstr ""

#: ../branches.rst:126
msgid "**recursive**"
msgstr ""

#: ../branches.rst:128
msgid "This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. Additionally this can detect and handle merges involving renames. This is the default merge strategy when pulling or merging one branch."
msgstr ""

#: ../branches.rst:130
msgid "**octopus**"
msgstr ""

#: ../branches.rst:132
msgid "This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch."
msgstr ""

#: ../branches.rst:134
msgid "**ours**"
msgstr ""

#: ../branches.rst:136
msgid "This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches."
msgstr ""

#: ../branches.rst:138
msgid "**subtree**"
msgstr ""

#: ../branches.rst:140
msgid "This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree."
msgstr ""

#: ../branches.rst:142
msgid "Squash commits"
msgstr ""

#: ../branches.rst:143
msgid "Allow unrelated histories"
msgstr ""

#: ../branches.rst:144
msgid "Add log messages, with an input field for specifying number of log messages to add"
msgstr ""

#: ../branches.rst:145
msgid "Specify merge message, with an input field for specifying a custom merge message"
msgstr ""

#: ../branches.rst:148
msgid "Rebase branch"
msgstr ""

#: ../branches.rst:150
msgid "The rebase command is the most complex command in Git. The rebase command is very similar to the merge command. Both rebase and merge are used to get a branch up-to-date. The main difference is that rebase can be used to keep the history linear contrary to merges."
msgstr ""

#: ../branches.rst:156
msgid "Select the commit where you want to to rebase the current branch."
msgstr ""

#: ../branches.rst:160
msgid "A rebase of feature/refactor on top of master will perform the following actions:"
msgstr ""

#: ../branches.rst:162
msgid "All commits specific to the feature/refactor branch will be stashed in a temporary location"
msgstr ""

#: ../branches.rst:163
msgid "The branch feature/refactor will be removed"
msgstr ""

#: ../branches.rst:164
msgid "The branch feature/refactor will be recreated on the master branch"
msgstr ""

#: ../branches.rst:165
msgid "All commits will be recommitted in the new feature/refactor branch"
msgstr ""

#: ../branches.rst:169
msgid "During a rebase merge conflicts can occur. You need to solve the merge conflicts for each commit that is rebased. The rebase function in Git Extensions will guide you through all steps needed for a successful rebase. See :ref:`merge_conflicts` for more information."
msgstr ""

#: ../branches.rst:174
msgid "The image below shows the commit log after the rebase. Notice that the history is changed and it seems like the commits on the feature/refactor branch are created after the commits on the master branch."
msgstr ""

#: ../branches.rst:181
msgid "Because this function rewrites history you should only use this on branches that are not published to other repositories yet. When you rebase a branch that is already pushed it will be harder to pull or push to that remote. If you want to get a branch up-to-date that is already published you should merge."
msgstr ""

#: ../branches.rst:186
msgid "Interactive rebase"
msgstr ""

#: ../branches.rst:188
msgid "It is possible to modify the order, merge commits etc when committing."
msgstr ""

#: ../branches.rst:190
msgid "See :ref:`modify_history` for more information."
msgstr ""

#: ../branches.rst:193
msgid "Squash"
msgstr ""

#: ../branches.rst:195
msgid "Git has no native squash operation, it can be done with various combinations of rebase and reset. This is described in the `Git Extensions wiki <https://github.com/gitextensions/gitextensions/wiki/How-To%3A-Squash-and-Rebase-your-changes#squash>`_."
msgstr ""

#: ../branches.rst:198
msgid "See :ref:`modify_history` and `Git documentation <https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History>`_ for more information."
msgstr ""

#: ../branches.rst:201
msgid "Delete branch"
msgstr ""

#: ../branches.rst:203
msgid "Since it is common to create many branches, it is often necessary to delete branches. Most commonly you will need to delete branches on which work has finished and their contents are merged into master or your main branch. You can also delete unmerged branches when they are not needed anymore and you do not want to keep the work done in that branch."
msgstr ""

#: ../branches.rst:207
msgid "When you delete a branch that is not yet merged, all of the commits that are in only the deleted branch will be lost. When you delete a branch that is already merged with another branch, the merged commits will not be lost because they are also part of another branch."
msgstr ""

#: ../branches.rst:211
msgid "You can delete a branch using ``Delete branch`` from the ``Commands`` menu. If you want to delete a branch that is not merged into your current branch (``HEAD`` in Git), you need to check the ``Force delete`` checkbox."
msgstr ""
