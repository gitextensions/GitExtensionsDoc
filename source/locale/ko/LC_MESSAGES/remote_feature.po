# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013, GitExtensions
# This file is distributed under the same license as the GitExtensions package.
# 
# Translators:
# 임지윤 <dtrlml26@ajou.ac.kr>, 2020
# LEE Hwanyong <hwan@ajou.ac.kr>, 2023
msgid ""
msgstr ""
"Project-Id-Version: Git Extensions Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-28 18:30+0300\n"
"PO-Revision-Date: 2015-05-24 19:19+0000\n"
"Last-Translator: LEE Hwanyong <hwan@ajou.ac.kr>, 2023\n"
"Language-Team: Korean (http://app.transifex.com/git-extensions/git-extensions-manual/language/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ..\remote_feature.rst:2
msgid "Remote feature"
msgstr "원격 기능"

#: ..\remote_feature.rst:4
msgid ""
"Git is a distributed source control management system. This means that all "
"changes you make are local. When you commit changes, you only commit them to"
" your local repository. To publish your local changes you need to push. In "
"order to get changes committed by others, you need to pull."
msgstr "깃은 분산 소스 제어 관리 시스템입니다. 이는 모든 변경 사항이 로컬임을 의미합니다. 변경 사항을 커밋 할 때 로컬 리포지토리에만 커미트합니다. 로컬 변경 사항을 게시하려면 푸시해야 합니다. 다른 사람이 커미트 한 변경 사항을 얻으려면 풀해야 합니다."

#: ..\remote_feature.rst:9
msgid "Manage remote repositories"
msgstr "원격 리포지토리 합병"

#: ..\remote_feature.rst:11
msgid "You can manage the remote repositories in the ``Remotes`` menu."
msgstr "\"원격\" 메뉴에서 원격 리포지토리를 관리할 수 있습니다."

#: ..\remote_feature.rst:15
msgid ""
"When you cloned your repository from a public repository, this remote is "
"already configured. You can rename each remote for easy recognition. The "
"default name after cloning a remote is ``origin``. If you use PuTTY as SSH "
"client you can also enter the private key file for each remote. Git "
"Extensions will load the key when needed. How to create a private key file "
"is described in the next paragraph."
msgstr "공용 리포지토리에서 리포지토리를 복제 할 때 이 원격은 이미 구성되어 있습니다. 쉽게 알아볼 수 있도록 각 원격의 이름을 바꿀 수 있습니다. 원격 복제 후 기본 이름은 \"origin\"입니다. PuTTY를 SSH 클라이언트로 사용하는 경우 각 원격에 대한 개인 키 파일을 입력 할 수도 있습니다. 깃 익스텐션은 필요할 때 키를 로드합니다. 개인 키 파일을 생성하는 방법은 다음 단락에서 설명합니다."

#: ..\remote_feature.rst:22
msgid ""
"In the ``Default pull behaviour`` tab you can configure the branches that "
"need to be pulled and merged by default. If you configure this correctly you"
" will not need to choose a branch when you pull or push. There are two "
"buttons on this dialog:"
msgstr "\"기본 풀 동작\" 탭에서 기본적으로 풀 하고 병합해야 하는 브랜치를 구성 할 수 있습니다. 이를 올바르게 구성하면 풀이나 푸시를 할 때 브랜치를 선택할 필요가 없습니다. 이 대화 상자에는 두 개의 버튼이 있습니다:"

#: ..\remote_feature.rst:26
msgid "Prune remote branches"
msgstr "원격 브랜치 정리"

#: ..\remote_feature.rst:26
msgid "Throw away remote branches that do not exist on the remote anymore."
msgstr "더 이상 원격에 존재하지 않는 원격 브랜치를 버립니다."

#: ..\remote_feature.rst:28
msgid "Update all remote branch info"
msgstr "모든 원격 브랜치 정보 업데이트"

#: ..\remote_feature.rst:28
msgid "Fetch all remote branch information."
msgstr "모든 원격 브랜치 정보 페치"

#: ..\remote_feature.rst:33
msgid ""
"After cloning a repository you do not need to configure all remote branches "
"manually. Instead you can checkout the remote branch and choose to create a "
"local tracking branch."
msgstr "리포지토리를 복제 한 후에는 모든 원격 브랜치를 수동으로 구성 할 필요가 없습니다. 대신 원격 브랜치를 체크 아웃하고 로컬 추적 브랜치를 생성하도록 선택할 수 있습니다."

#: ..\remote_feature.rst:37
msgid "Create SSH key"
msgstr "SSH 키 생성"

#: ..\remote_feature.rst:39
msgid ""
"Git uses SSH for accessing private repositories. SSH uses a public/private "
"key pair for authentication. This means you need to generate a private key "
"and a public key. The private key is stored on your computer locally and the"
" public key can be given to anyone. SSH will encrypt whatever you send using"
" your secret private key. The receiver will then use the public key you send"
" to decrypt the data."
msgstr "깃은 비공개 리포지토리에 접근하기 위해 SSH를 사용합니다. SSH는 인증을 위해 공개/개인 키 쌍을 사용합니다. 즉, 개인 키와 공개 키를 생성해야 합니다. 개인 키는 컴퓨터에 로컬로 저장되며 공개 키는 누구에게나 제공 될 수 있습니다. SSH는 비밀 개인 키를 사용하여 보내는 모든 것을 암호화합니다. 그러면 수신자는 전송한 공개 키를 사용하여 데이터를 해독합니다."

#: ..\remote_feature.rst:44
msgid ""
"This encryption will not protect the data itself but it protects the "
"authenticity. Because the private key is only available to the sender, the "
"receiver can be sure about the origin of the data. In practise the key pair "
"is only used for the authentication process. The data itself will be "
"encrypted using a key that is exchanged during this initial phase."
msgstr "이 암호화는 데이터 자체를 보호하지 않지만 신뢰성을 보호합니다. 개인 키는 발신자만 사용할 수 있으므로 수신자는 데이터의 출처를 확신 할 수 있습니다. 실제로 키 쌍은 인증 프로세스에만 사용됩니다. 데이터 자체는 이 초기 단계에서 교환되는 키를 사용하여 암호화됩니다."

#: ..\remote_feature.rst:49
msgid "PuTTY and github"
msgstr "PuTTY 와 깃허브"

#: ..\remote_feature.rst:51
msgid ""
"PuTTY is SSH client that for Windows that is a bit more user friendly then "
"OpenSSH. Unfortunately PuTTY does not work with all servers. In this "
"paragraph I will show how to generate a key for github using putty."
msgstr "PuTTY는 OpenSSH보다 더 사용자 친화적인 윈도우 용 SSH 클라이언트입니다. 불행히도 PuTTY는 모든 서버에서 작동하지 않습니다. 이 단락에서는 putty를 사용하여 깃허브 용 키를 생성하는 방법을 보여줍니다."

#: ..\remote_feature.rst:54
msgid ""
"First make sure GitExtensions is configured to use PuTTY and all paths are "
"correct."
msgstr "먼저 깃 익스텐션이 PuTTY를 사용하도록 구성되어 있는지와 모든 경로가 올바른지 확인하십시오."

#: ..\remote_feature.rst:60
msgid "can choose ``Generate or import key`` to start the key generator."
msgstr "\"키 생성 또는 가져 오기\"를 선택하여 키 생성기를 시작할 수 있습니다.\n "

#: ..\remote_feature.rst:66
msgid ""
"PuTTY will ask you to move the mouse around to generate a more random key. "
"When the key is generated you can save the public and the private key in a "
"file. You can choose to protect the private key with a password but this is "
"not necessary."
msgstr "PuTTY는 더 많은 임의의 키를 생성하기 위해 마우스를 움직일 것을 요청합니다. 키가 생성되면 공개 및 개인 키를 파일에 저장할 수 있습니다. 비밀번호로 개인 키를 보호하도록 선택할 수 있지만 필수는 아닙니다."

#: ..\remote_feature.rst:69
msgid ""
"Now you have a key pair you need to give github the public key. This can be "
"done in ``Account Settings`` in the tab ``SSH Public Keys``. You can add "
"multiple keys here, but you only need one key for all repositories."
msgstr "이제 깃허브에 공개 키를 제공해야 하는 키 쌍이 있습니다. 이것은 \"SSH 공개 키\" 탭의 \"계정 설정\"에서 수행 할 수 있습니다. 여기에 여러 키를 추가 할 수 있지만 모든 리포지토리에 대해 하나의 키만 필요합니다."

#: ..\remote_feature.rst:74
msgid ""
"After telling github what public key to use to decrypt, you need to tell "
"GitExtensions what private key to use to encrypt. In the clone dialog there "
"is a ``Load SSH key`` button to load the private key into the PuTTY "
"authentication agent. This can also be done manually by starting the PuTTY "
"authentication agent and choose ``add key`` in the context menu in the "
"system tray."
msgstr "복호화에 사용할 공개 키를 깃허브에 지정한 후 암호화에 사용할 개인 키를 깃 익스텐션에 알려야합니다. 복제 대화 상자에는 PuTTY 인증 에이전트에 개인 키를 로드하는 \"SSH 키 로드\" 버튼이 있습니다. PuTTY 인증 에이전트를 시작하고 시스템 트레이의 상황 메뉴에서 \"키 추가\"를 선택하여 수동으로 수행할 수도 있습니다."

#: ..\remote_feature.rst:80
msgid ""
"GitExtensions can load the private keys automatically for you when "
"communicating with a remote. You need to configure the private key for the "
"remote."
msgstr "깃 익스텐션은 원격과 통신할 때 자동으로 개인 키를 로드 할 수 있습니다. 원격에 대한 개인 키를 구성해야 합니다."

#: ..\remote_feature.rst:83
msgid "This is done in the ``Manage remote repositories`` dialog."
msgstr "이 작업은 \"원격 저장소 관리\" 대화 상자에서 수행됩니다."

#: ..\remote_feature.rst:86
msgid "OpenSSH and github"
msgstr "OpenSSH와 깃허브"

#: ..\remote_feature.rst:88
msgid ""
"When you choose to use OpenSSH you need to configure GitExtensions as shown "
"in the screenshot below."
msgstr " OpenSSH 사용을 선택한 경우 아래 스크린 샷과 같이 깃 익스텐션을 설정해야 합니다."

#: ..\remote_feature.rst:92
msgid ""
"OpenSSH is the best SSH client there is but it lacks Windows support. "
"Therefore it is slightly more complex to use. Another drawback is that "
"GitExtensions cannot control OpenSSH and needs to show the command line "
"dialogs when OpenSSH might be used. GitExtensions will show the command line"
" window for every command that might require a SSH connection. For this "
"reason PuTTY is the prefered SSH client in GitExtensions."
msgstr "OpenSSH는 최고의 SSH 클라이언트이지만 윈도우 지원이 부족합니다. 따라서 사용하기에 약간 더 복잡합니다. 또 다른 단점은 깃 익스텐션이 OpenSSH를 제어 할 수 없으며 OpenSSH를 사용할 수 있을 때 명령 행 대화 상자를 표시해야 한다는 것입니다. 깃 익스텐션은 SSH 연결이 필요할 수 있는 모든 명령에 대한 명령 행 창을 표시합니다. 이러한 이유로 PuTTY는 깃 익스텐션에서 선호되는 SSH 클라이언트입니다."

#: ..\remote_feature.rst:97
msgid ""
"To generate a key pair in OpenSSH you need to go to the command line. I "
"recommend to use the git bash because the path to OpenSSH is already set."
msgstr "OpenSSH에서 키 쌍을 생성하려면 명령 행으로 이동해야합니다. OpenSSH에 대한 경로가 이미 설정되어 있으므로 깃 배쉬를 사용하는 것을 권합니다."

#: ..\remote_feature.rst:102
msgid ""
"Type the following command: ``ssh-keygen -C \"your@email.com\" -t rsa`` Use "
"the same email address as the email address used in git. You will be asked "
"where if you want to protect the private key with a password. This is not "
"necessary. By default the public and private keys are stored in "
"``c:\\Documents and Settings\\[User]\\.ssh\\`` or "
"``c:\\Users\\[user]\\.ssh\\``."
msgstr "다음 명령을 입력합니다: \"ssh-keygen -C \"your@email.com\"-t rsa\" git에서 사용된 이메일 주소와 동일한 이메일 주소를 사용해야 합니다. 비밀번호로 개인 키를 보호 할 위치를 묻는 메시지가 표시됩니다. 이것은 필요하지 않습니다. 기본적으로 공개 및 개인 키는 \"c:\\Documents and Settings\\[User]\\.ssh\\\" 또는 \"c:\\Users\\[user]\\.ssh\\\"에 저장됩니다."

#: ..\remote_feature.rst:109
msgid ""
"You do not need to tell GitExtensions about the private key because OpenSSH "
"will load it for you. Now open the public key using notepad and copy the key"
" to github. This can be done in ``Account Settings`` in the tab ``SSH Public"
" Keys`` on `GitHub <http://www.github.com>`_."
msgstr "OpenSSH가 자동으로 로드하므로 깃 익스텐션에 개인 키에 대해 알릴 필요가 없습니다. 이제 메모장을 사용하여 공개 키를 열고 키를 깃허브에 복사합니다. 이것은 '깃허브 <http://www.github.com>' 의 \"SSH 공개 키\" 탭에 있는 \"계정 설정\"에서 할 수 있습니다."

#: ..\remote_feature.rst:116
msgid "Pull changes"
msgstr "변경 사항 풀"

#: ..\remote_feature.rst:118
msgid ""
"You can get remote changes using the pull function. Before you can pull "
"remote changes you need to make sure there are no uncommitted changes in "
"your local repository. If you have uncommitted changes you should commit "
"them or stash them during the pull. You can read about how to use the stash "
"in the Stash chapter."
msgstr "풀 기능을 사용하여 원격 변경 사항을 가져올 수 있습니다. 원격 변경 사항을 가져 오기 전에 로컬 리포지토리에 커미트되지 않은 변경 사항이 없는지 확인해야 합니다. 커미트되지 않은 변경 사항이 있는 경우 풀을 하는 동안 커미트하거나 스태시해야 합니다. 스태시 챕터에서 스태시 사용 방법에 대해 읽을 수 있습니다."

#: ..\remote_feature.rst:124
msgid ""
"In order to get your personal repository up-to-date, you need to fetch "
"changes from a remote repository. You can do this using the ``Pull`` dialog."
" When the dialog starts the default remote for the current branch is set. "
"You can choose another remote or enter a custom url if you like. When the "
"remote branches configured correctly, you do not need to choose a remote "
"branch."
msgstr "개인 리포지토리를 최신 상태로 유지하려면 원격 리포지토리에서 변경 사항을 가져와야 합니다. `\"풀\" 대화 상자를 사용하여 이 작업을 수행 할 수 있습니다. 대화 상자가 시작되면 현재 브랜치에 대한 기본 원격이 설정됩니다. 원하는 경우 다른 원격을 선택하거나 맞춤 URL을 입력 할 수 있습니다. 원격 브랜치가 올바르게 구성되면 원격 브랜치를 선택할 필요가 없습니다."

#: ..\remote_feature.rst:128
msgid ""
"If you just fetch the commits from the remote repository and you already "
"committed some changes to your local repository, the commits will be in a "
"different branch. In the pull dialog this is illustrated in the image on the"
" left. This can be useful when you want to review the changes before you "
"want to merge them with your own changes."
msgstr "원격 리포지토리에서 커미트를 가져오고 로컬 리포지토리에 이미 일부 변경 사항을 커미트 한 경우 커미트는 다른 브랜치에 있습니다. 풀 대화 상자에서 이것은 왼쪽 이미지에 설명되어 있습니다. 이것은 자신의 변경 사항과 병합하기 전 변경 사항을 검토하려는 경우에 유용할 수 있습니다."

#: ..\remote_feature.rst:135
msgid ""
"When you choose to merge the remote branch after fetching the changes a "
"branch will be created, and will be merged into your commit. Doing this "
"creates a lot of branches and merges, making the history harder to read."
msgstr "변경 사항을 가져온 후 원격 브랜치를 병합하도록 선택하면 브랜치가 생성되고 커미트에 병합됩니다. 이렇게 하면 많은 브랜치와 병합이 생성되어 기록을 읽기가 더 어려워집니다."

#: ..\remote_feature.rst:140
msgid ""
"Instead of merging the fetched commits with your local commits, you can also"
" choose to rebase your commits on top of the fetched commits. This is "
"illustrated on the left in the image below. A rebase will first undo your "
"local commits (c and d), then fetch the remote commits (e) and finally "
"recommit your local commits. When there is a merge conflict during the "
"rebase, the rebase dialog will show."
msgstr "가져온 커미트를 로컬 커미트와 병합하는 대신 가져온 커미트 위에 커미트를 리베이스 하도록 선택할 수도 있습니다. 이것은 아래 이미지의 왼쪽에 설명되어 있습니다. 리베이스는 먼저 로컬 커미트 (c 및 d)를 실행 취소 한 다음 원격 커미트 (e)를 가져오고 마지막으로 로컬 커미트를 다시 커미트합니다. 리베이스 중에 병합 충돌이 발생하면 리베이스 대화 상자가 표시됩니다."

#: ..\remote_feature.rst:147
msgid "Next to the pull button there are some buttons that can be useful:"
msgstr "풀 버튼 옆에 유용한 몇 가지 버튼이 있습니다:"

#: ..\remote_feature.rst:150
msgid "Solve conflicts"
msgstr "충돌 해결"

#: ..\remote_feature.rst:150
msgid ""
"When there are merge conflicts, you can solve them by pressing this button."
msgstr "병합 충돌이 있는 경우 이 버튼을 눌러 해결할 수 있습니다."

#: ..\remote_feature.rst:152
msgid "Stash changes"
msgstr "변경 사항 스태시"

#: ..\remote_feature.rst:152
msgid ""
"When the working dir contains uncommitted changes, you need to stash them "
"before pulling."
msgstr "작업 디렉토리에 커미트되지 않은 변경 사항이 포함된 경우 가져오기 전에 스태시해야 합니다."

#: ..\remote_feature.rst:154
msgid "Auto stash"
msgstr "자동 스태시"

#: ..\remote_feature.rst:154
msgid ""
"Check this checkbox if you want to stash before pulling. The stash will be "
"reapplied after pulling."
msgstr "풀하기 전에 스태시하려면 이 선택란을 선택합니다. 스태시는 풀을 한 후 다시 적용됩니다."

#: ..\remote_feature.rst:156
msgid "Load SSH key"
msgstr "SSH 키 로드"

#: ..\remote_feature.rst:156
msgid ""
"This button is only available when you use PuTTY as SSH client. You can "
"press this button to load the key configured for the remote. If no key is "
"set, a dialog will prompt for the key."
msgstr "이 버튼은 PuTTY를 SSH 클라이언트로 사용하는 경우에만 사용할 수 있습니다. 이 버튼을 눌러 원격에 구성된 키를 로드 할 수 있습니다. 키가 설정되어 있지 않으면 키를 입력하라는 대화 상자가 나타납니다."

#: ..\remote_feature.rst:161
msgid "Push changes"
msgstr "변경 사항 푸시"

#: ..\remote_feature.rst:163
msgid ""
"In the browse window you can check if there are local commits that are not "
"pushed to a remote repository yet. In the image below the green labels mark "
"the position of the master branch on the remote repository. The red label "
"marks the position of the master branch on the local repository. The local "
"repository is ahead three commits."
msgstr "탐색창에서 아직 원격 리포지토리로 푸시되지 않은 로컬 커미트가 있는지 확인할 수 있습니다. 아래 이미지에서 녹색 레이블은 원격 리포지토리에서 마스터 브랜치의 위치를 ​​표시합니다. 빨간색 레이블은 로컬 리포지토리에서 마스터 브랜치의 위치를 ​​표시합니다. 로컬 리포지토리는 세 커미트보다 앞서 있습니다."

#: ..\remote_feature.rst:169
msgid "To push the changes press ``Push`` in the toolbar."
msgstr "변경 사항을 푸시하려면 도구 막대에서 \"푸시\" 버튼을 누릅니다."

#: ..\remote_feature.rst:173
msgid ""
"The push dialog allows you to choose the remote repository to push to. The "
"remote repository is set to the remote of the current branch. You can choose"
" another remote or choose a url to push to. You can also specify a branch to"
" push."
msgstr "푸시 대화 상자를 사용하면 푸시 할 원격 리포지토리를 선택할 수 있습니다. 원격 리포지토리는 현재 브랜치의 원격으로 설정됩니다. 다른 원격을 선택하거나 푸시 할 URL을 선택할 수 있습니다. 푸시 할 브랜치를 지정할 수도 있습니다."

#: ..\remote_feature.rst:178
msgid ""
"Tags are not pushed to the remote repository. If you want to push a tag you "
"need to open the ``Tags`` tab in the dialog. You can choose to push a singe "
"tag or all tags. No commits will be pushed when the ``Tags`` tab is "
"selected, only tags."
msgstr "태그는 원격 리포지토리로 푸시되지 않습니다. 태그를 푸시하려면 대화 상자에서 \"태그\" 탭을 열어야합니다. 단일 태그 또는 모든 태그를 푸시하도록 선택할 수 있습니다. \"태그\" 탭을 선택하면 커미트가 푸시되지 않고 태그만 푸시됩니다."

#: ..\remote_feature.rst:181
msgid ""
"You can not merge your changes in the remote repository. Merging must be "
"done locally. This means that you cannot push your changes before the "
"commits are merged locally. In practice you need to pull before you can push"
" most of the times."
msgstr "원격 리포지토리에서 변경 사항을 병합 할 수 없습니다. 병합은 로컬에서 수행해야 합니다. 즉, 커미트가 로컬로 병합되기 전에 변경 사항을 푸시 할 수 없습니다. 실제로는 대부분의 경우 푸시하기 전에 풀을 해야 합니다."
