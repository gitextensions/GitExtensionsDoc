# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013, GitExtensions
# This file is distributed under the same license as the GitExtensions package.
# 
# Translators:
# 임지윤 <dtrlml26@ajou.ac.kr>, 2020
# LEE Hwanyong <hwan@ajou.ac.kr>, 2023
msgid ""
msgstr ""
"Project-Id-Version: Git Extensions Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-05-24 23:16+0300\n"
"PO-Revision-Date: 2015-05-24 19:18+0000\n"
"Last-Translator: LEE Hwanyong <hwan@ajou.ac.kr>, 2023\n"
"Language-Team: Korean (http://app.transifex.com/git-extensions/git-extensions-manual/language/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ..\branches.rst:2
msgid "Branches"
msgstr "브랜치"

#: ..\branches.rst:7
msgid ""
"Branches are used to commit changes separate from other commits. It is very "
"common to create a new branch when you start working on a feature to keep "
"the work done on that feature separate from other work. When the feature is "
"complete the branch can be merged or rebased as you choose such that the "
"commits for the feature either remain as a parallel branch or appear as a "
"continuous single line of development as if the branch had never existed in "
"the first place. The image on the right illustrates a branch created on top "
"of commit B."
msgstr "브랜치는 다른 커미트와 별도로 변경 사항을 커미트하는 데 사용됩니다. 기능에 대한 작업을 시작할 때 해당 기능에 대해 수행된 작업을 다른 작업과 별도로 유지하기 위해 새 브랜치를 만드는 것은 상당히 일반적입니다. 기능이 완성되면 선택에 따라 기능에 대한 커미트가 병렬 분기로 유지되거나 마치 처음부터 분기가 존재하지 않았던 것처럼 연속적인 단일 개발 라인으로 나타나도록 분기를 병합하거나 재지정할 수 있습니다. 오른쪽 이미지는 커미트 B 위에 생성된 브랜치를 보여줍니다."

#: ..\branches.rst:13
msgid ""
"You can see the name of your current branch in a combo box in the toolbar. "
"You can switch to another branch by choosing from the combo box list. In the"
" commit log the current branch has an arrow head to the left of its name. If"
" you are not currently on a branch because you have checked out a specific "
"commit but not any particular branch then Git Extensions will show ``(no "
"branch)`` in place of a branch name in the toolbar. This is called "
"\"Detached HEAD mode\". In Git you can refer to your current branch or "
"commit by the special reference ``HEAD`` in place of the branch name or "
"commit reference."
msgstr "도구 막대의 콤보 상자에서 현재 브랜치의 이름을 볼 수 있습니다. 콤보 상자 목록에서 선택을 통해 다른 브랜치로 전환할 수 있습니다. 커미트 로그에서 현재 브랜치는 이름 왼쪽에 화살표가 있습니다. 특정 커미트를 체크아웃했지만 특정 분기를 체크아웃하지 않아 현재 브랜치에 있지 않은 경우 깃 익스텐션은 도구 막대에서 분기 이름 대신 \"(분기 없음)\"을 보여줄 것입니다. 이를 \"Detached HEAD mode\"라고 합니다. 깃에서는 현재 브랜치를 참조하거나 브랜치 이름대신 \"HEAD\"라는 특별 참조로 커미트하거나 참조를 커미트 할 수 있습니다."

#: ..\branches.rst:23
msgid "Create branch"
msgstr "브랜치 생성"

#: ..\branches.rst:25
msgid ""
"In Git Extensions there are multiple ways to create a new branch. In the "
"image below I create a new branch from the context menu in the commit log. "
"This will create a new branch on the revision that is selected."
msgstr "깃 익스텐션에서 새로운 브랜치를 생성하는 다양한 방법이 있습니다. 아래 사진은 커미트 로그의 상황 메뉴에서 새로운 브랜치를 생성합니다. 이렇게 하면 선택한 개정에 새로운 브랜치가 생성됩니다."

#: ..\branches.rst:30
msgid ""
"I will create a new branch called ``Refactor``. In this branch I can do "
"whatever I want without affecting others. The default in Git Extensions is "
"to check out a new branch after it is created. If you want to create a new "
"branch but remain on your current branch, uncheck the ``Checkout after "
"create`` checkbox in the ``Create branch`` dialog."
msgstr "\"리팩터\"라고 불리는 새로운 브랜치를 생성할 것입니다. 이 브랜치에서 다른 사람들에게 영향을 주지 않고 원하는 것은 무엇이든지 할 수 있습니다. 깃 익스텐션에서 기본값은 새 브랜치가 생성된 후 새 브랜치를 체크아웃하는 것입니다. 새로운 브랜치 생성 후 현재 브랜치에 남아있으려면 \"브랜치 생성\" 대화상자에서 \"생성 후 체크아웃\" 선택란의 선택을 취소합니다."

#: ..\branches.rst:36
msgid ""
"When the branch is created you will see the new branch ``Refactor`` in the "
"commit log. If you chose to checkout this branch the next commit will be "
"committed to the new branch."
msgstr "브랜치가 생성되면 커미트 로그에서 새 브랜치인 \"리팩터\"를 볼 수 있습니다. 이 브랜치를 체크아웃으로 선택한 경우 다음 커미트는 새 브랜치에 커미트됩니다."

#: ..\branches.rst:41
msgid ""
"Creating branches in Git requires only 41 bytes of space in the repository. "
"Creating a new branch is very easy and fast. The complete work flow of Git "
"is optimized for branching and merging."
msgstr "깃에 브랜치를 생성하려면 리포지토리에 41바이트 공간만을 필요로 합니다. 새 브랜치의 생성은 매우 쉽고 빠릅니다. 깃의 전체 작업 흐름은 브랜치 생성과 병합에 최적화되어 있습니다."

#: ..\branches.rst:45
msgid "Orphan branches"
msgstr "고아 브랜치"

#: ..\branches.rst:46
msgid ""
"In special cases it is helpful to have orphan branches (see for example "
"https://www.google.com/search?q=why+use+orphan+branches+in+git). Check the "
"\"Create orphan\" checkbox to create an orphan branch (``--orphan`` option "
"in git)."
msgstr "특별한 상황에서 고아 브랜치가 있는 것은 유용합니다(예: https://www.google.com/search?q=why+use+orphan+branches+in+git). 고아 브랜치를 만들기 위해 \"고아 생성\"선택란을 선택합니다.(깃에서 \"--orphan\" 옵션)"

#: ..\branches.rst:49
msgid "The newly created branch will have no parent commits."
msgstr "새로 생성된 분기는 부모 커미트가 없습니다."

#: ..\branches.rst:51
msgid ""
"The option \"Clear working dir and index\" (``git rm -rf``) is active by "
"default. So the working dir and index will be cleared. If you uncheck the "
"last option then the working dir and index will not be touched."
msgstr "\"작업 디렉토리 및 색인 지우기\"(\"git rm -rf\") 옵션은 기본적으로 활성화되어 있습니다. 그러므로 작업 디렉토리와 색인은 지워질 것입니다. 마지막 옵션의 선택을 취소하면 작업 디렉토리와 색인은 간섭받지 않습니다."

#: ..\branches.rst:55
msgid "Checkout branch"
msgstr "브랜치 체크아웃 "

#: ..\branches.rst:57
msgid ""
"You can switch from the current branch to another branch using the checkout "
"command. Checking out a branch sets the current branch and updates all of "
"the source files in the working directory. Uncommitted changes in the "
"working directory can be overwritten so it is best practice to make sure "
"your working directory is clean by either committing or stashing any current"
" changes before checking out a branch. If you do not clean your working "
"directory then, in the ``Checkout branch`` dialog, you can choose between "
"four options for your local uncommitted changes:"
msgstr "체크아웃 명령을 사용하여 현재 브랜치에서 다른 브랜치로 전환할 수 있습니다. 브랜치를 체크아웃하면 현재 브랜치가 설정되고 작업 디렉토리의 모든 소스 파일이 업데이트 됩니다. 작업 디렉토리에서 커미트되지 않은 변경사항은 덮어쓰여질 수 있으므로 분기를 체크아웃하기 전에 현재 변경사항을 커미트하거나 스태시하여 작업 디렉토리가 깨끗한지 확인하는 것이 좋습니다. 작업 디렉토리를 정리하지 않은 경우 \"브랜치 체크아웃\" 대화상자에서 커미트되지 않은 로컬 변경사항에 대해 네 가지 옵션 중 하나를 선택할 수 있습니다."

#: ..\branches.rst:64
msgid "``Don't change``"
msgstr "\"바꾸지 않음\""

#: ..\branches.rst:64
msgid ""
"Local changes will be retained if there are not conflicting changes from the"
" branch you are checking out."
msgstr "체크아웃할 브랜치에서 변경 사항이 충돌하지 않을 경우 로컬 변경사항이 유지됩니다."

#: ..\branches.rst:66
msgid "``Merge``"
msgstr "\"병합\""

#: ..\branches.rst:66
msgid ""
"Performs a three-way merge between your current branch, your local changes "
"and the branch you are checking out."
msgstr "현재 브랜치, 로컬 변경 사항 및 체크아웃할 브랜치 간에 세 방향 병합을 수행합니다."

#: ..\branches.rst:68
msgid "``Stash``"
msgstr "\"스태시\""

#: ..\branches.rst:68
msgid ""
"Your local changes are stashed and the new branch is checked out. You can "
"retrieve your changes on the new branch with stash-pop."
msgstr "로컬 변경 사항이 스태시되고 새 브랜치가 체크아웃 됩니다. 새 브랜치에 대한 변경 사항을 stash-pop으로 되돌릴 수 있습니다."

#: ..\branches.rst:70
msgid "``Reset``"
msgstr "\"리셋\""

#: ..\branches.rst:70
msgid ""
"Your local changes are discarded and the new branch is checked out. Use "
"caution with this option as Git has no record of uncommitted changes so they"
" cannot be retrieved."
msgstr "로컬 변경 사항이 삭제되고 새 브랜치가 체크아웃 됩니다. 깃에는 커미트되지 않은 변경사항의 레코드가 없어 되돌릴 수 없으므로 이 옵션 사용에 주의해야 합니다."

#: ..\branches.rst:76
msgid "Merge branches"
msgstr "브랜치 병합"

#: ..\branches.rst:78
msgid ""
"In the image below there are two branches, ``[Refactor]`` and ``[master]``. "
"We can merge the commits from the master branch into the Refactor branch. If"
" we do this, the Refactor branch will be up to date with the master branch, "
"but not the other way around. As long as we are working on the Refactor "
"branch we cannot touch the master branch itself. We can merge the sources of"
" master into our branch, but cannot make any change to the master branch."
msgstr "아래 그림에 \"[리팩터]\"와 \"[마스터]\"라는 두 가지 브랜치가 있습니다. 마스터 브랜치에서 리팩터 브랜치로 커미트를 병합할 수 있습니다. 이렇게 하면 리팩터 브랜치는 마스터 브랜치와 최신 상태가 되겠지만, 반대는 그렇지 않습니다. 리팩터 브랜치에서 작업하는 한 마스터 브랜치 자체에 간섭할 수 없습니다. 마스터의 소스를 우리의 브랜치로 병합할 수 있지만 마스터 브랜치에는 어떠한 변화도 줄 수 없습니다."

#: ..\branches.rst:85
msgid ""
"To merge the Refactor branch into the master branch, we first need to switch"
" to the master branch."
msgstr "리팩터 브랜치를 마스터 브랜치에 병합하려면 먼저 마스터 브랜치로 전환해야 합니다."

#: ..\branches.rst:89
msgid ""
"Once we are on the master branch we can choose merge by choosing ``Merge "
"branches`` from the ``Commands`` menu. In the merge dialog you can verify "
"which branch you are working on. Select the branch to merge with then click "
"the ``Merge`` button."
msgstr "일단 마스터 브랜치에 있으면 \"명령\" 메뉴에서 \"브랜치 병합\"을 선택하여 병합을 선택할 수 있습니다. 병합 대화 상자에서 작업 중인 브랜치를 확인할 수 있습니다. 병합할 브랜치를 선택한 후 \"병합\" 버튼을 클릭합니다."

#: ..\branches.rst:94
msgid ""
"After the merge the commit log will show the new commit containing the "
"merge. Notice that the Refactor branch is not changed by this merge. If you "
"want to continue working on the Refactor branch you can merge the Refactor "
"branch with master. You can instead delete the Refactor branch if it is not "
"used anymore."
msgstr "병합 후 커미트 로그에 병합이 포함된 새 커미트가 보여집니다. 리팩터 브랜치는 이 병합에 의해 변경되지 않는다는 것을 주의해야 합니다. 리팩터 브랜치에 대한 작업을 계속하길 원한다면 리팩터 브랜치를 마스터와 병합할 수 있습니다. 대신 리팩터 브랜치가 더 이상 사용되지 않는 경우 삭제할 수 있습니다."

#: ..\branches.rst:102
msgid ""
"When you need to merge with an unnamed branch you can use a tag to give it a"
" temporary name."
msgstr "이름 없는 브랜치와 병합해야 하는 경우엔 태그를 사용하여 임시적으로 이름을 지정할 수 있습니다."

#: ..\branches.rst:105
msgid "Rebase branch"
msgstr "브랜치 리베이스"

#: ..\branches.rst:107
msgid ""
"The rebase command is the most complex command in Git. The rebase command is"
" very similar to the merge command. Both rebase and merge are used to get a "
"branch up-to-date. The main difference is that rebase can be used to keep "
"the history linear contrary to merges."
msgstr "리베이스 명령은 깃에서 가장 복잡한 명령입니다. 리베이스 명령은 병합 명령과 매우 유사합니다. 리베이스와 병합은 둘 다 브랜치를 최신 상태로 만드는 데 사용됩니다. 주요 차이점은 병합과 반대로 리베이스는 기록을 선형적으로 유지하는데 사용할 수 있다는 점입니다."

#: ..\branches.rst:113
msgid ""
"A rebase of Refactor on top of master will perform the following actions:"
msgstr "마스터 위에 있는 리팩터의 리베이스는 다음 작업을 수행합니다."

#: ..\branches.rst:115
msgid ""
"All commits specific to the Refactor branch will be stashed in a temporary "
"location"
msgstr "리팩터 브랜치로 특정되는 모든 커미트는 임시 위치에 스태시됩니다."

#: ..\branches.rst:116
msgid "The branch Refactor will be removed"
msgstr "리팩터 브랜치는 삭제됩니다."

#: ..\branches.rst:117
msgid "The branch Refactor will be recreated on the master branch"
msgstr "리팩터 브랜치는 마스터 브랜치 위에 재생성 됩니다."

#: ..\branches.rst:118
msgid "All commits will be recommitted in the new Refactor branch"
msgstr "새로운 리팩터 브랜치에서 모든 커미트는 다시 커미트 됩니다."

#: ..\branches.rst:120
msgid ""
"During a rebase merge conflicts can occur. You need to solve the merge "
"conflicts for each commit that is rebased. The rebase function in Git "
"Extensions will guide you through all steps needed for a successful rebase."
msgstr "리베이스 중에 병합 충돌이 발생할 수 있습니다. 리베이스되는 각 커미트에 대한 병합 충돌을 해결해야 합니다. 깃 익스텐션의 리베이스 기능은 성공적인 리베이스에 필요한 모든 단계를 안내합니다."

#: ..\branches.rst:125
msgid ""
"The image below shows the commit log after the rebase. Notice that the "
"history is changed and it seems like the commits on the Refactor branch are "
"created after the commits on the master branch."
msgstr "아래 이미지는 리베이스 후 커미트 로그를 보여줍니다. 기록이 변경되는 것과 리팩터 브랜치에 대한 커미트가 마스터 브랜치에 커미트 후에 생성되는 것처럼 보인다는 것을 주의해야 합니다."

#: ..\branches.rst:132
msgid ""
"Because this function rewrites history you should only use this on branches "
"that are not published to other repositories yet. When you rebase a branch "
"that is already pushed it will be harder to pull or push to that remote. If "
"you want to get a branch up-to-date that is already published you should "
"merge."
msgstr "이 기능은 기록을 다시 쓰기 때문에 아직 다른 레포지토리에 게시되지 않은 브랜치에만 사용해야 합니다. 이미 푸시한 브랜치를 리베이스하면 원격으로 풀이나 푸시하기가 더 어려워집니다. 이미 게시된 브랜치를 최신 상태로 가져오려면 병합해야 합니다."

#: ..\branches.rst:137
msgid "Delete branch"
msgstr "브랜치 삭제"

#: ..\branches.rst:139
msgid ""
"Since it is common to create many branches, it is often necessary to delete "
"branches. Most commonly you will need to delete branches on which work has "
"finished and their contents are merged into master or your main branch. You "
"can also delete unmerged branches when they are not needed anymore and you "
"do not want to keep the work done in that branch."
msgstr "많은 브랜치를 만드는 것이 일반적이기 때문에 브랜치를 삭제해야 하는 경우가 종종 필요합니다. 가장 일반적으로 작업이 완료되고 해당 내용이 마스터 또는 메인 브랜치로 병합된 브랜치를 삭제해야 합니다. 병합되지 않은 브랜치가 더 이상 필요하지 않고 해당 브랜치에서 작업을 계속 수행하지 않으려는 경우에도 삭제할 수 있습니다."

#: ..\branches.rst:143
msgid ""
"When you delete a branch that is not yet merged, all of the commits that are"
" in only the deleted branch will be lost. When you delete a branch that is "
"already merged with another branch, the merged commits will not be lost "
"because they are also part of another branch."
msgstr "아직 합병되지 않은 브랜치를 삭제하면 삭제된 브랜치에만 있는 모든 커미트는 손실됩니다. 이미 다른 브랜치와 합병된 브랜치를 삭제하면 합병된 커미트는 다른 브랜치의 일부이므로 손실되지 않습니다."

#: ..\branches.rst:147
msgid ""
"You can delete a branch using ``Delete branch`` from the ``Commands`` menu. "
"If you want to delete a branch that is not merged into your current branch "
"(``HEAD`` in Git), you need to check the ``Force delete`` checkbox."
msgstr "\"명령\" 메뉴에서 \"브랜치 삭제\"를 사용하여 분기를 삭제할 수 있습니다. 현재 브랜치(깃에서 \"HEAD\")로 합병되지 않은 브랜치을 삭제하려면 \"강제 삭제\" 선택란을 선택해야 합니다."
